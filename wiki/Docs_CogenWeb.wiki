#summary cogen.web Documentation for trunk
#labels Documentation

==== Parent module: [Docs_Cogen cogen] ====
==== Modules: [Docs_CogenWebAsync async] [Docs_CogenWebWsgi wsgi] ====

= Module: web =
This module holds a wsgi server and future web-related code.

== Modules ==

=== [Docs_CogenWebAsync async] ===
cogen.web.wsgi server is asynchronous by default. If you need to run a app that
uses wsgi.input synchronously you need to wrapp it in 
`SynchronousInputMiddleware`.

Wsgi asynchronous api only provides a read operation at the moment. Here's a
example:

{{{
buff = StringIO()
while 1:
    yield environ['cogen.input'].Read(self.buffer_length)
    result = environ['cogen.wsgi'].result
    if isinstance(result, Exception):
        import traceback
        traceback.print_exception(*environ['cogen.wsgi'].exception)
        break
    else:
        if not result:
            break
        buff.write(result)
buff.seek(0)
# ...
# do something with the data
# ...
}}}


=== [Docs_CogenWebWsgi wsgi] ===
This wsgi server is a single threaded, single process server that interleaves 
the iterations of the wsgi apps - I could add a threadpool for blocking apps in 
the future.

If you don't return iterators from apps and return lists you'll get, at most,
the performance of a server that processes requests sequentialy.

On the other hand this server has coroutine extensions that suppose to support 
use of middleware in your application. 

Example app with coroutine extensions:

{{{
def wait_app(environ, start_response):
  start_response('200 OK', [('Content-type','text/html')])
  yield "I'm waiting for some signal"
  yield environ['cogen'].core.events.WaitForSignal("abc", timeout=1)
  if isinstance(environ['cogen'].result, Exception):
    yield "Your time is up !"
  else:
    yield "Someone signaled me: %s" % environ['cogen'].result
}}}

  * `environ['cogen'].core` is actualy a wrapper that sets 
  `environ['cogen'].operation` with the called object and returns a empty 
  string. This should penetrate most of the middleware - according to the wsgi 
  spec, middleware should pass a empty string if it doesn't have anything to 
  return on that specific iteration point, or, in other words, the length of the
  app iter returned by middleware should be at least that of the app.
  
  * the wsigi server will set `environ['cogen'].result` with the result of the 
  operation and `environ['cogen'].exception` with the details of the 
  exception - if any: `(exc_type, exc_value, traceback_object)`.

HTTP handling code taken from the CherryPy WSGI server.



