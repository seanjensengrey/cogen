#summary cogen.core.events Documentation for trunk
#labels Documentation

==== Parent module: [Docs_CogenCore cogen.core] ====
==== Classes: [Docs_CogenCoreEventsAddcoro AddCoro] [Docs_CogenCoreEventsCall Call] [Docs_CogenCoreEventsComplete Complete] [Docs_CogenCoreEventsConnectionclosed ConnectionClosed] [Docs_CogenCoreEventsConnectionerror ConnectionError] [Docs_CogenCoreEventsCoroutineexception CoroutineException] [Docs_CogenCoreEventsJoin Join] [Docs_CogenCoreEventsOperation Operation] [Docs_CogenCoreEventsOperationtimeout OperationTimeout] [Docs_CogenCoreEventsPass Pass] [Docs_CogenCoreEventsSignal Signal] [Docs_CogenCoreEventsSleep Sleep] [Docs_CogenCoreEventsTimedoperation TimedOperation] [Docs_CogenCoreEventsWaitforsignal WaitForSignal] ====

= Module: `events` =
Base events (coroutine operations) and coroutine exceptions.

== Classes ==

=== [Docs_CogenCoreEventsAddcoro AddCoro] ===
A operator for adding a coroutine in the scheduler.
Example:

{{{
yield events.AddCoro(some_coro, args=(), kwargs={})
}}}


=== [Docs_CogenCoreEventsCall Call] ===
This will pause the current coroutine, add a new coro in the scheduler and 
resume the callee when it returns.

Usage:
{{{
result = yield events.Call(mycoro, args=, kwargs=, prio=)
}}}

  * if `prio` is set the new coroutine will be added in the top of the 
  scheduler queue


=== [Docs_CogenCoreEventsComplete Complete] ===
A operator for adding a list of (coroutine, operator) pairs. Used 
internally.


=== [Docs_CogenCoreEventsConnectionclosed ConnectionClosed] ===
Raised when the other peer has closed connection.


=== [Docs_CogenCoreEventsConnectionerror ConnectionError] ===
Raised when a socket has a error flag (in epoll or select)


=== [Docs_CogenCoreEventsCoroutineexception CoroutineException] ===
This is used intenally to carry exception state in the poller and 
scheduler.


=== [Docs_CogenCoreEventsJoin Join] ===
A operator for waiting on a coroutine. 
Example:

{{{
@coroutine
def coro_a():
    return_value = yield events.Join(ref)
    
    
@coroutine
def coro_b():
    yield "bla"
    raise StopIteration("some return value")

ref = scheduler.add(coro_b)
scheduler.add(coro_a)
}}}


=== [Docs_CogenCoreEventsOperation Operation] ===
All operations derive from this. This base class handles 
the priority flag. 

Eg:

{{{
yield Operation(prio=)
}}}        

If you need something that can't be done in a coroutine fashion you 
probabily need to subclass this and make a custom operation for your
issue.


=== [Docs_CogenCoreEventsOperationtimeout OperationTimeout] ===
Raised when the timeout for a operation expires. The exception 
message will be the operation


=== [Docs_CogenCoreEventsPass Pass] ===
A operator for setting the next (coro, op) pair to be runned by the 
scheduler. Used internally.


=== [Docs_CogenCoreEventsSignal Signal] ===
This will resume the coroutines that where paused with WaitForSignal.

Usage:

{{{
nr = yield events.Signal(name, value)
}}}

  * nr - the number of coroutines woken up


=== [Docs_CogenCoreEventsSleep Sleep] ===
Usage:

{{{
yield events.Sleep(time_object)
}}}

  * timeoject - a datetime or timedelta object, or a number of seconds
    
{{{
yield events.Sleep(timestamp=ts)
}}}

  * ts - a timestamp


=== [Docs_CogenCoreEventsTimedoperation TimedOperation] ===
Operations that have a timeout derive from this.

Eg:

{{{
yield TimedOperation(
    timeout=, 
    weak_timeout=,
    prio=
)
}}}


=== [Docs_CogenCoreEventsWaitforsignal WaitForSignal] ===
The coroutine will resume when the same object is Signaled.



