#summary cogen.web.async Documentation
#labels Documentation

==== Parent: [CogenWeb cogen.web] ====
==== Classes: [CogenWebAsyncCogenoperationcall COGENOperationCall] [CogenWebAsyncCogenoperationwrapper COGENOperationWrapper] [CogenWebAsyncCogenproxy COGENProxy] [CogenWebAsyncRead Read] [CogenWebAsyncSynchronousinputmiddleware SynchronousInputMiddleware] ====

= Module: async =
cogen.web.wsgi server is asynchronous by default. If you need to run a app that
uses wsgi.input synchronously you need to wrapp it in 
`SynchronousInputMiddleware`.

Wsgi asynchronous api only provides a read operation at the moment. Here's a
example:

{{{
buff = StringIO()
while 1:
    yield environ['cogen.input'].Read(self.buffer_length)
    result = environ['cogen.wsgi'].result
    if isinstance(result, Exception):
        import traceback
        traceback.print_exception(*environ['cogen.wsgi'].exception)
        break
    else:
        if not result:
            break
        buff.write(result)
buff.seek(0)
# ...
# do something with the data
# ...
}}}

== Classes ==

=== [CogenWebAsyncCogenoperationcall COGENOperationCall] ===



=== [CogenWebAsyncCogenoperationwrapper COGENOperationWrapper] ===



=== [CogenWebAsyncCogenproxy COGENProxy] ===



=== [CogenWebAsyncRead Read] ===
This is actually a hack that mixes ReadAll and ReadLine and 
patches their state attributes. Hopefully i'll evolve it to
something more elegant at some point.


=== [CogenWebAsyncSynchronousinputmiddleware SynchronousInputMiddleware] ===
Middleware for providing wsgi.input to the app.



