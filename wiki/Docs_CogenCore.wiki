#summary cogen.core Documentation for trunk
#labels Documentation

==== Parent module: [Docs_Cogen cogen] ====
==== Modules: [Docs_CogenCoreCoroutines coroutines] [Docs_CogenCoreEvents events] [Docs_CogenCorePubsub pubsub] [Docs_CogenCoreQueue queue] [Docs_CogenCoreReactors reactors] [Docs_CogenCoreSchedulers schedulers] [Docs_CogenCoreSockets sockets] [Docs_CogenCoreUtil util] ====

= Module: `core` =
This module holds the essential stuff.

Programming with this library should be straghtforward. A coroutine is just 
a generator wrapped in a operation handling class:

{{{
@coroutine
def mycoro(bla):
    yield 
    yield 
}}}
    
  * the `operation` instructs the scheduler what to do with the 
  coroutine: suspend it till someting happens, add another coro in 
  the scheduler, raise a event and so on.
  * the `operations` are split up in 2 modules: events and sockets
    * the `operations` from sockets are related to network, like reading and 
    writing, and these are done asynchronously but your code in the 
    coroutine will see them as a regular synchronous or blocking call.
    * the `operations` from events are related to signals and 
    coroutine/scheduler management.
  * if a `operation` has a result associated then the yield will return that 
  result (eg. a string or a (connection, address) tuple) otherwise it will 
  return the operation instance.

Typical example:

{{{
import sys, os
from cogen.common import *

@coroutine
def server():
    srv = sockets.Socket()
    srv.setblocking(0)
    srv.bind(('localhost',777))
    srv.listen(10)
    while 1:
        print "Listening..."
        conn, addr = yield sockets.Accept(srv)
        print "Connection from %s:%s" % addr
        m.add(handler, conn, addr)
        
@coroutine
def handler(sock, addr):
    yield sockets.Write(sock, "WELCOME TO ECHO SERVER !\r\n")
    while 1:
        line = yield sockets.ReadLine(sock, 8192)
        if line.strip() == 'exit':
            yield sockets.Write(sock, "GOOD BYE")
            sock.close()
            return
            
        yield sockets.Write(sock, line)
        
m = Scheduler()
m.add(server)
m.run()
}}}

== Modules ==

=== [Docs_CogenCoreCoroutines coroutines] ===
Coroutine related boilerplate and wrappers.


=== [Docs_CogenCoreEvents events] ===
Base events (coroutine operations) and coroutine exceptions.


=== [Docs_CogenCorePubsub pubsub] ===



=== [Docs_CogenCoreQueue queue] ===
Port of Queue.Queue from the python standard library.


=== [Docs_CogenCoreReactors reactors] ===
Network polling code.

The reactor works in tandem with the socket operations.
Here's the basic workflow:

  * the coroutine yields a operation
  * the scheduler runs that operation (the [Docs_CogenCoreEventsOperation#process process] method)
    Note: all the socket operations share the same [Docs_CogenCoreSocketsSocketoperation#process process] method
    * if run_first is False then the operation is added in the reactor for 
    polling (with the exception that if we have data in out internal buffers
    the operation is runned first)
    * if run_first is set (it's default) in the operation then in process 
    method the reactor's [Docs_CogenCoreReactorsReactorbase#run_or_add run_or_add] 
    is called with the operation and coroutine

  
Note: run_first is a optimization hack really, first it tries to run the
operation (this asumes the sockets are usualy ready) and if it raises any 
exceptions like EAGAIN, EWOULDBLOCK etc it adds that operation for polling 
(via select, epoll, kqueue etc) then the run method will be called only when 
select, epoll, kqueue says that the socket is ready.


=== [Docs_CogenCoreSchedulers schedulers] ===
Scheduling framework.

The scheduler handles the timeouts, run the operations and does very basic 
management of coroutines. Most of the heavy logic is in each operation class.
See: [Docs_CogenCoreEvents events] and [Docs_CogenCoreSockets sockets]
Most of those operations work with attributes we set in the scheduler.


=== [Docs_CogenCoreSockets sockets] ===
Socket-only coroutine operations and `Socket` wrapper.
Really - the only thing you need to know for most stuff is 
the [Docs_CogenCoreSocketsSocket Socket] class.


=== [Docs_CogenCoreUtil util] ===
Mischelaneous or common.



