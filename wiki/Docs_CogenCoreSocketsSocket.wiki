#summary cogen.core.sockets.Socket Documentation for trunk
#labels Documentation

==== Parent module: [Docs_CogenCoreSockets cogen.core.sockets] ====
==== Methods: [#accept accept] [#bind bind] [#close close] [#connect connect] [#fileno fileno] [#getpeername getpeername] [#getsockname getsockname] [#gettimeout gettimeout] [#listen listen] [#read read] [#readall readall] [#readline readline] [#setblocking setblocking] [#setsockopt setsockopt] [#settimeout settimeout] [#shutdown shutdown] [#write write] [#writeall writeall] ====

= Class: `Socket` =

A wrapper for socket objects, sets nonblocking mode and
adds some internal bufers and wrappers. Regular calls to the usual 
socket methods return operations for use in a coroutine.

So you use this in a coroutine like:
{{{
    sock = Socket(family, type, proto) # just like the builtin socket module
    yield sock.read(1024)
}}}

Constructor details:
{{{
    Socket([family[, type[, proto]]]) -> socket object
}}}
Open a socket of the given type.  The family argument specifies the
address family; it defaults to AF_INET.  The type argument specifies
whether this is a stream (SOCK_STREAM, this is the default)
or datagram (SOCK_DGRAM) socket.  The protocol argument defaults to 0,
specifying the default protocol.  Keyword arguments are accepted.

A socket object represents one endpoint of a network connection.

== Methods ==

=== {{{accept}}} ===
signature: {{{accept(self)}}}

Accept a connection. The socket must be bound to an address and 
listening for connections. The return value is a pair (conn, address) 
where conn is a new socket object usable to send and receive data on the 
connection, and address is the address bound to the socket on the other 
end of the connection. 

Example:
{{{
conn, address = yield mysock.accept()
}}}

=== {{{bind}}} ===
signature: {{{bind(self, *args)}}}

Bind the socket to _address_. The socket must not already be bound. 
(The format of _address_ depends on the address family) 

=== {{{close}}} ===
signature: {{{close(self, *args)}}}

Close the socket. All future operations on the socket object will 
fail. The remote end will receive no more data (after queued data is 
flushed). Sockets are automatically closed when they are garbage-collected. 

=== {{{connect}}} ===
signature: {{{connect(self, address)}}}

Connect to a remote socket at _address_. 

=== {{{fileno}}} ===
signature: {{{fileno(self)}}}

Return the socket's file descriptor 

=== {{{getpeername}}} ===
signature: {{{getpeername(self)}}}

Return the remote address to which the socket is connected.

=== {{{getsockname}}} ===
signature: {{{getsockname(self, *args)}}}

Return the socket's own address. 

=== {{{gettimeout}}} ===
signature: {{{gettimeout(self, *args)}}}

Return the associated timeout value. 

=== {{{listen}}} ===
signature: {{{listen(self, backlog)}}}

Listen for connections made to the socket. The _backlog_ argument 
specifies the maximum number of queued connections and should be at 
least 1; the maximum value is system-dependent (usually 5). 

=== {{{read}}} ===
signature: {{{read(self, bufsize)}}}

Receive data from the socket. The return value is a string 
representing the data received. The amount of data may be less than the
ammount specified by _bufsize_. 

=== {{{readall}}} ===
signature: {{{readall(self, bufsize)}}}

Receive data from the socket. The return value is a string 
representing the data received. The amount of data will be the exact
ammount specified by _bufsize_. 

=== {{{readline}}} ===
signature: {{{readline(self, size)}}}

Receive one line of data from the socket. The return value is a string 
representing the data received. The amount of data will at most
ammount specified by _size_. If no line separator has been found and the 
ammount received has reached _size_ an OverflowException will be raised.

=== {{{setblocking}}} ===
signature: {{{setblocking(self, val)}}}



=== {{{setsockopt}}} ===
signature: {{{setsockopt(self, *args)}}}

Set the value of the given socket option. Same as the usual socket 
method.

=== {{{settimeout}}} ===
signature: {{{settimeout(self, to)}}}

Set a timeout on blocking socket operations. The value argument can 
be a nonnegative float expressing seconds, timedelta or None. 

=== {{{shutdown}}} ===
signature: {{{shutdown(self, *args)}}}

Shut down one or both halves of the connection. Same as the usual 
socket method.

=== {{{write}}} ===
signature: {{{write(self, data)}}}

Send data to the socket. The socket must be connected to a remote 
socket. Ammount sent may be less than the data provided.

=== {{{writeall}}} ===
signature: {{{writeall(self, data)}}}

Send data to the socket. The socket must be connected to a remote 
socket. All the data is guaranteed to be sent.


