#summary cogen.web.async Documentation for trunk
#labels Documentation

==== Parent module: [Docs_CogenWeb cogen.web] ====
==== Classes: [Docs_CogenWebAsyncCogenoperationcall COGENOperationCall] [Docs_CogenWebAsyncCogenoperationwrapper COGENOperationWrapper] [Docs_CogenWebAsyncCogenproxy COGENProxy] [Docs_CogenWebAsyncRead Read] [Docs_CogenWebAsyncReadline ReadLine] [Docs_CogenWebAsyncSynchronousinputmiddleware SynchronousInputMiddleware] ====
==== Functions: [#sync_input sync_input] ====

= Module: async =
cogen.web.wsgi server is asynchronous by default. If you need to run a app that
uses wsgi.input synchronously you need to wrapp it in 
`SynchronousInputMiddleware`.

Wsgi asynchronous api only provides a read operation at the moment. Here's a
example:

{{{
buff = StringIO()
while 1:
    yield environ['cogen.input'].Read(self.buffer_length)
    result = environ['cogen.wsgi'].result
    if isinstance(result, Exception):
        import traceback
        traceback.print_exception(*environ['cogen.wsgi'].exception)
        break
    else:
        if not result:
            break
        buff.write(result)
buff.seek(0)
# ...
# do something with the data
# ...
}}}

== Classes ==

=== [Docs_CogenWebAsyncCogenoperationcall COGENOperationCall] ===



=== [Docs_CogenWebAsyncCogenoperationwrapper COGENOperationWrapper] ===



=== [Docs_CogenWebAsyncCogenproxy COGENProxy] ===



=== [Docs_CogenWebAsyncRead Read] ===
This is actually a hack that mixes ReadAll and ReadLine and 
patches their state attributes. Hopefully i'll evolve it to
something more elegant at some point.


=== [Docs_CogenWebAsyncReadline ReadLine] ===
Same a async.Read but doesn't work with chunked input (it would complicate
things too much at the moment).


=== [Docs_CogenWebAsyncSynchronousinputmiddleware SynchronousInputMiddleware] ===
Middleware for providing wsgi.input to the app.



== Functions ==

=== {{{sync_input}}} ===
signature: {{{sync_input(app)}}}





