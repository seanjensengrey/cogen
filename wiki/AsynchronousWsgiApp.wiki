#summary Introduction to asynchronous features of cogen.web.wsgi
#labels Featured

= Introduction =

The idea is to support asynchronous operations: that is give the wsgi app ability to pause itself, resume when something happens and make available the result of that _something_.
In `cogen` that _something_ is a operation.

Another desired feature is to allow use of middleware. We achieve this by yielding empty strings in the app and saving the operation to be run in a object from `environ` - wsgi spec specifies that middleware should yield at least as many chunks as the wrapped app has yielded [http://www.python.org/dev/peps/pep-0333/#middleware-handling-of-block-boundaries 1]. Though not any middleware follows that to the letter - you have to look at `cogen.web.wsgi` as to a streaming server - if the middleware flattens the response the breakage will occur as operations aren't send to the wsgi server and the app is not paused.

`cogen.web.wsgi` provides 3 nice objects in the environ that eases writing apps like this.

  * {{{environ['cogen.core']}}} - a wrapper that sets `environ['cogen.wsgi'].operation` with the called object and returns a empty string. This should penetrate all the compilant middleware - take note of the flatten issue above.
  * `environ['cogen.wsgi']` - this is a object for communications between the app and the server
    * `environ['cogen.wsgi'].result` - holds the result of the operation, if a error occured it will be a instance of `Exception`
    * `environ['cogen.wsgi'].operation` - hold the operation to run - you don't need to fiddle with need - just use `environ['cogen.core']`
    * `environ['cogen.wsgi'].exception` - holds complete information about the error occurred: `(type, value, traceback)`
  * `environ['cogen.input']` - at the moment only holds a Read operation and it is used exactly as `environ['cogen.core']`:
    * `environ['cogen.input'].Read`

Check the docstring generated documentation too !

== Example app with coroutine extensions ==

{{{
def wait_app(environ, start_response):
    start_response('200 OK', [('Content-type','text/html')])
    yield "I'm waiting for some signal<br>"
    yield environ['cogen.core'].events.WaitForSignal("abc", timeout=5)
    if isinstance(environ['cogen.wsgi'].result, Exception):
        yield "Your time is up !"
    else:
        yield "Someone signaled me with this message: %s" % cgi.escape(`environ['cogen.wsgi'].result`)
}}}

== Example reading the input asynchronously ==

{{{
buff = StringIO()
while 1:
    yield environ['cogen.input'].Read(8192)
    result = environ['cogen.wsgi'].result
    if isinstance(result, Exception):
        import traceback
        traceback.print_exception(*environ['cogen.wsgi'].exception)
        break
    else:
        if not result:
            break
        buff.write(result)
buff.seek(0)                                                            
}}}