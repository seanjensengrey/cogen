#summary cogen.core.schedulers.Scheduler Documentation for trunk
#labels Documentation

==== Parent module: [Docs_CogenCoreSchedulers cogen.core.schedulers] ====
==== Methods: [#add add] [#add_timeout add_timeout] [#handle_timeouts handle_timeouts] [#iter_run iter_run] [#next_timer_delta next_timer_delta] [#process_op process_op] [#run run] [#stop stop] ====

= Class: `Scheduler` =

Basic deque-based scheduler with timeout support and primitive 
prioritisaiton parameters.

Usage:
{{{Scheduler(reactor=DefaultReactor, default_priority=priority.LAST, default_timeout=None)}}}

  * reactor: a reactor class to use
  * default_priority: a default priority option for operations that do not 
  set it. check [Docs_CogenCoreUtilPriority priority].
  * default_timeout: a default timedelta or number of seconds to wait for 
  the operation, -1 means no timeout.

== Methods ==

=== {{{add}}} ===
signature: {{{add(self, coro, args=(), kwargs={}, first=True)}}}

Add a coroutine in the scheduler. You can add arguments 
(_args_, _kwargs_) to init the coroutine with.

=== {{{add_timeout}}} ===
signature: {{{add_timeout(self, op, coro, weak_timeout)}}}



=== {{{handle_timeouts}}} ===
signature: {{{handle_timeouts(self)}}}

Handle timeouts. Raise timeouted operations with a OperationTimeout 
in the associated coroutine (if they are still alive and the operation
hasn't actualy sucessfuly completed) or, if the operation has a 
weak_timeout flag, update the timeout point and add it back in the 
heapq.

weak_timeout notes:        
  * weak_timeout means a last_update attribute is updated with
  a timestamp of the last activity in the operation - for example, a
  may recieve new data and not complete (not enough data, etc)
  * if there was activity since the last time we've cheched this 
  timeout we push it back in the heapq with a timeout value we'll check 
  it again

Also, we call a cleanup on the op, only if cleanup return true we raise 
the timeout (finalized isn't enough to check if the op has completed 
since finalized is set when the operation gets back in the coro - and
it might still be in the Scheduler.active queue when we get to this 
timeout - well, this is certainly a problem magnet: TODO: fix_finalized)

=== {{{iter_run}}} ===
signature: {{{iter_run(self)}}}

The actual processing for the main loop is here.

Running the main loop as a generator (where a iteration is a full 
sched, reactor and timers/timeouts run) is usefull for interleaving
the main loop with other applications that have a blocking main loop and 
require cogen to run in the same thread.

=== {{{next_timer_delta}}} ===
signature: {{{next_timer_delta(self)}}}

Returns a timevalue that the reactor will wait on.

=== {{{process_op}}} ===
signature: {{{process_op(self, op, coro)}}}

Process a (op, coro) pair and return another pair. Handles exceptions.

=== {{{run}}} ===
signature: {{{run(self)}}}

This is the main loop.
This loop will exit when there are no more coroutines to run or stop has
been called.

=== {{{stop}}} ===
signature: {{{stop(self)}}}




